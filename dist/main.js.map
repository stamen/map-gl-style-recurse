{"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;A,Y,C;A,S,6B,C,M,E,c,E;I,I,I,G,M,C,I,C,M,C,A;I,I,M,C,qB,E;Q,I,O,G,M,C,qB,C,M,C,A;Q,c,I,C,O,G,O,C,M,C,S,G,E;Y,O,M,C,wB,C,M,E,G,C,C,U,C;S,C,C,A,E,I,C,I,C,K,C,I,E,O,C,C;K;I,O,I,C;C;A,S,mC,C,M,E;I,I,I,C,G,C,E,C,G,S,C,M,E,C,E,C;Q,I,M,G,I,I,S,C,C,C,G,S,C,C,C,G,E,A;Q,C,G,C,G,6B,C,M,C,M,C,E,C,C,C,C,O,C,S,G,E;Y,qC,C,M,E,G,E,M,C,G,C,C,C;S,C,G,M,C,yB,G,M,C,gB,C,M,E,M,C,yB,C,M,C,C,G,6B,C,M,C,M,C,C,C,O,C,S,G,E;Y,M,C,c,C,M,E,G,E,M,C,wB,C,M,E,G,C,C,C;S,C,C;K;I,O,M,C;C;A,S,qC,C,G,E,G,E,K,E;I,I,G,I,G,E,M,C,c,C,G,E,G,E;Q,K,E,K;Q,U,E,I;Q,Y,E,I;Q,Q,E,I;K,C,C;S,G,C,G,C,G,K,C;I,O,G,C;C;A,S,6B,C,I,E;I,O,6B,G,U,I,O,M,I,Q,I,O,M,C,Q,G,S,G,E;Q,O,O,G,C;K,G,S,G,E;Q,O,G,I,U,I,O,M,I,G,C,W,K,M,I,G,K,M,C,S,G,Q,G,O,G,C;K,E,6B,C,I,C,C;C;AAAA;;;;;GAKA,CAEA;;;;;;;;GAQA,CAEA;;;;;;;GAOA,CAEA;;;;;;;;;GASA,CACA,IAAMA,uCAAiB,GAAG,SAApBA,iBAAoB,CACxBC,OADwB,EAExBC,WAFwB,EAGxBC,GAHwB,EAIxBC,WAJwB,EAKxBC,kBALwB,EAMrB;IACH,IAAIA,kBAAkB,CAACF,GAAD,EAAMD,WAAN,CAAtB,EACE,OAAOE,WAAW,CAACH,OAAD,EAAUE,GAAV,EAAeD,WAAf,CAAlB,CAAA;IAEF,IAAII,KAAK,CAACC,OAAN,CAAcJ,GAAd,CAAJ,EACE,OAAOA,GAAG,CAACK,GAAJ,CAAQ,SAAAC,IAAI,EAAnB;QAAmB,OACjBT,iBAAiB,CACfC,OADe,EAEfC,WAFe,EAGfO,IAHe,EAIfL,WAJe,EAKfC,kBALe,C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","sources":["src/lib/create-recurse-style.js","src/index.js"],"sourcesContent":["/**\n * @param {Object} options - options object to be passed with args to alter style\n * @param {transformFn} options.transformFn - the transform function to run on property values\n * @param {transformCondition} [options.transformCondition] - optional function for condition to be met to transform property\n * @param {Array} [options.propertyIds] - optional array of property ids to filter transform to\n */\n\n/**\n * transformFn\n * The transform function passed in as an option to run recursively on expressions\n * @function transformFn\n * @param {string} layerId - id of the relevant layer\n * @param {Object|Array|string|number} propertyValue - the value of the property passed in\n * @param {string} propertyKey - the key of the property passed in\n * @returns {Object|Array|string|number} - transformed property value\n */\n\n/**\n * transformCondition\n * Returns a boolean for if the condition is met\n * @function transformCondition\n * @param {Object|Array|string|number} propertyValue - the value of the property passed in\n * @param {string} propertyKey - the key of the property passed in\n * @returns {boolean} - true or false\n */\n\n/**\n * recurseExpression\n * Recurses an expression and passes all sub expressions to transformFn\n * @param {string} layerId - id of the relevant layer\n * @param {string} propertyKey - key of the property where the expression was found\n * @param {Array} exp - expression\n * @param {transformFn} transformFn - transforms the value\n * @param {transformCondition} transformCondition - returns true if value meets condition\n * @returns {Array} - modified expression\n */\nconst recurseExpression = (\n  layerId,\n  propertyKey,\n  exp,\n  transformFn,\n  transformCondition\n) => {\n  if (transformCondition(exp, propertyKey)) {\n    return transformFn(layerId, exp, propertyKey);\n  }\n  if (Array.isArray(exp)) {\n    return exp.map(item =>\n      recurseExpression(\n        layerId,\n        propertyKey,\n        item,\n        transformFn,\n        transformCondition\n      )\n    );\n  }\n  return exp;\n};\n\n/**\n * updatePropertyValue\n * Returns updated property value\n * @param {string} layerId - id of the relevant layer\n * @param {string} propertyKey - key of the property where the value was found\n * @param {Object|Array|string|number} propertyValue - property value\n * @param {Object} options - options object with transform fn and optional recurse condition\n * @returns {Object|Array|string|number} - modified property value\n */\nconst updatePropertyValue = (layerId, propertyKey, propertyValue, options) => {\n  const { transformFn, transformCondition } = options;\n  let propertyFormat = typeof propertyValue;\n  if (!transformCondition) return transformFn(propertyValue, propertyKey);\n\n  if (propertyFormat === 'object' && Array.isArray(propertyValue)) {\n    propertyFormat = 'expression';\n  } else if (\n    propertyFormat === 'object' &&\n    propertyValue.hasOwnProperty('stops')\n  ) {\n    propertyFormat = 'legacyStops';\n  } else {\n    propertyFormat = 'literal';\n  }\n\n  switch (propertyFormat) {\n    case 'literal':\n      return transformCondition(propertyValue, propertyKey)\n        ? transformFn(layerId, propertyValue, propertyKey)\n        : propertyValue;\n    case 'expression':\n      // Since expressions can be nested, recurse through the expression to find any instance that meets the condition\n      return recurseExpression(\n        layerId,\n        propertyKey,\n        propertyValue,\n        transformFn,\n        transformCondition\n      );\n    case 'legacyStops':\n      return {\n        ...propertyValue,\n        stops: recurseExpression(\n          layerId,\n          propertyKey,\n          propertyValue.stops,\n          transformFn,\n          transformCondition\n        )\n      };\n  }\n};\n\n/**\n * updateLayerPropertyValues\n * Returns a layer or property object with all properties updated with appropriate value\n * @param {string} layerId - id of the relevant layer\n * @param {Object} propertyObj - property object, can be layer or paint/layout object\n * @param {Object} options - options object with transform fn, optional propertyIds, and optional recurse condition\n * @returns {Object} - modified property object\n */\nconst updateLayerPropertyValues = (layerId, propertyObj, options) => {\n  const { propertyIds } = options;\n  let nextObj = JSON.parse(JSON.stringify(propertyObj));\n\n  for (const k in propertyObj) {\n    switch (k) {\n      case 'metadata':\n        // Pass metadata straight through since it will not contain property values\n        break;\n      case 'paint':\n      case 'layout':\n        nextObj[k] = updateLayerPropertyValues(\n          layerId,\n          propertyObj[k],\n          options\n        );\n        break;\n      default:\n        // If specific properties are specified, only transform them\n        if (propertyIds && !propertyIds.includes(k)) continue;\n        const nextOptions = {\n          transformFn: options.transformFn,\n          transformCondition: options.transformCondition\n        };\n        // Handle nested keys here (to get \"paint.*\" and \"layout.*\")\n        nextObj[k] = updatePropertyValue(\n          layerId,\n          k,\n          propertyObj[k],\n          nextOptions\n        );\n        break;\n    }\n  }\n  return nextObj;\n};\n\n/**\n * recurseStyle\n * @param {Object} stylesheet - style json\n * @param {Object} options - options object with transform fn, optional propertyIds, and optional recurse condition\n * @returns {Object} - modified style json with single matches replaced\n */\nconst recurseStyle = (stylesheet, options) => {\n  // Copy stylesheet to not make edits in Maputnik\n  const stylesheetCopy = JSON.parse(JSON.stringify(stylesheet));\n\n  stylesheetCopy.layers = stylesheet.layers.map(l =>\n    updateLayerPropertyValues(l.id, l, options)\n  );\n\n  return stylesheetCopy;\n};\n\n/**\n * createRecurseStyle\n * @param {Object} options - options object with transform fn and optional recurse condition\n * @returns {Object} - modified style json with single matches replaced\n */\nconst createRecurseStyle = options => {\n  return stylesheet => recurseStyle(stylesheet, options);\n};\n\nmodule.exports = createRecurseStyle;\n","import createRecurseStyle from './lib/create-recurse-style';\n\nexport { createRecurseStyle };\n"],"names":["recurseExpression","layerId","propertyKey","exp","transformFn","transformCondition","Array","isArray","map","item","updatePropertyValue","propertyValue","options","propertyFormat","hasOwnProperty","stops","updateLayerPropertyValues","propertyObj","propertyIds","nextObj","JSON","parse","stringify","k","includes","nextOptions","recurseStyle","stylesheet","stylesheetCopy","layers","l","id","createRecurseStyle","module","exports"],"version":3,"file":"main.js.map"}